name: Sync Bluefin Releases

on:
  schedule:
    - cron: "0 10 * * *" # 6am US Eastern Time (ET) = 10:00 UTC
  workflow_dispatch:
  repository_dispatch:
    types: [bluefin-release]

jobs:
  sync-releases:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@ff7abcd0c3c05ccf6adc123a8cd1fd4fb30fb493
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup GitHub CLI
        run: |
          # GitHub CLI is pre-installed on ubuntu-latest
          gh --version
          
          # Set up authentication and verify it works
          echo "Setting up GitHub CLI authentication..."
          echo "${{ secrets.GITHUB_TOKEN }}" | gh auth login --with-token
          
          # Verify authentication works
          echo "Verifying GitHub CLI authentication..."
          gh auth status
          
          # Test basic API access
          echo "Testing API access..."
          gh api user --jq '.login' || {
            echo "‚ùå GitHub API authentication failed"
            exit 1
          }
          
          echo "‚úÖ GitHub CLI authentication successful"

      - name: Process releases
        id: process
        run: |
          echo "Processing releases..."
          
          # Function to fetch releases with retry logic
          fetch_releases_with_retry() {
            local repo="$1"
            local filter="$2"
            local max_attempts=3
            local attempt=1
            
            while [[ $attempt -le $max_attempts ]]; do
              echo "Attempting to fetch releases from $repo (attempt $attempt/$max_attempts)"
              
              local result
              if result=$(gh api "repos/$repo/releases" --paginate --jq "$filter" 2>&1); then
                echo "$result"
                return 0
              else
                echo "‚ùå API call failed (attempt $attempt/$max_attempts): $result"
                if [[ $attempt -lt $max_attempts ]]; then
                  echo "Retrying in 5 seconds..."
                  sleep 5
                fi
                ((attempt++))
              fi
            done
            
            echo "‚ùå Failed to fetch releases from $repo after $max_attempts attempts"
            echo "[]"
            return 1
          }

          # Function to validate release data completeness
          validate_release_data() {
            local release_json="$1"
            local tag="$2"
            
            # Check if basic fields are present
            local body_length=$(echo "$release_json" | jq -r '.body // ""' | wc -c)
            local name=$(echo "$release_json" | jq -r '.name // ""')
            local published_at=$(echo "$release_json" | jq -r '.published_at // ""')
            
            echo "üîç Validating release data for $tag:"
            echo "  - Name: '$name'"
            echo "  - Published: $published_at"
            echo "  - Body length: $body_length characters"
            
            # Validation checks
            if [[ -z "$published_at" || "$published_at" == "null" ]]; then
              echo "‚ùå Missing published_at timestamp"
              return 1
            fi
            
            if [[ $body_length -lt 100 ]]; then
              echo "‚ùå Release body too short ($body_length chars) - likely incomplete"
              echo "Body content: $(echo "$release_json" | jq -r '.body // ""')"
              return 1
            fi
            
            # Check for essential sections in release body
            local body_content=$(echo "$release_json" | jq -r '.body // ""')
            if ! echo "$body_content" | grep -q "### Major packages"; then
              echo "‚ö†Ô∏è WARNING: Missing '### Major packages' section"
            fi
            
            echo "‚úÖ Release data validation passed"
            return 0
          }

          # Function to process a single release
          process_release() {
            local repo="$1"
            local tag="$2"
            local url="$3"
            local date="$4"
            local name="$5"
            local body="$6"
            
            echo "Processing $repo:$tag (published: $date)"
            
            # Validate input parameters
            if [[ -z "$body" || "$body" == "null" ]]; then
              echo "‚ùå ERROR: Empty or null release body for $repo:$tag"
              echo "This may result in incomplete changelog generation"
              return 1
            fi
            
            # Log release body length for debugging
            BODY_LENGTH=$(echo "$body" | wc -c)
            echo "üìä Release body length: $BODY_LENGTH characters"
            
            # Check for minimum expected content
            if [[ $BODY_LENGTH -lt 500 ]]; then
              echo "‚ö†Ô∏è WARNING: Release body seems unusually short for $repo:$tag"
              echo "Body preview: $(echo "$body" | head -c 200)..."
            fi
            
            # Call existing script to process release with enhanced error handling
            if ./scripts/process_single_release.sh "$repo" "$tag" "$url" "$date" "$name" "$body" "false" ""; then
              echo "‚úÖ Successfully processed $repo:$tag"
              return 0
            else
              local exit_code=$?
              if [[ $exit_code -eq 1 ]]; then
                echo "‚ÑπÔ∏è Skipped $repo:$tag (already exists)"
                return 1
              else
                echo "‚ùå FAILED to process $repo:$tag (exit code: $exit_code)"
                echo "This indicates a serious issue with changelog generation"
                return 1
              fi
            fi
          }

          # Track processed releases
          PROCESSED_COUNT=0

          if [[ "${{ github.event_name }}" == "repository_dispatch" ]]; then
            # Handle single release from repository dispatch
            TAG="${{ github.event.client_payload.tag_name }}"
            URL="${{ github.event.client_payload.html_url }}"
            
            # Determine source repo from URL
            if [[ "$URL" == *"bluefin-lts"* ]] || [[ "$TAG" == lts-* ]]; then
              REPO="ublue-os/bluefin-lts"
            else
              REPO="ublue-os/bluefin"
            fi
            
            echo "Processing single release from repository dispatch: $REPO:$TAG"
            
            # Get release details with retry logic
            RELEASE_DATA=""
            for attempt in {1..3}; do
              echo "Fetching release details for $TAG (attempt $attempt/3)"
              if RELEASE_DATA=$(gh api "repos/$REPO/releases/tags/$TAG" 2>&1); then
                break
              else
                echo "‚ùå Failed to fetch release details (attempt $attempt/3): $RELEASE_DATA"
                if [[ $attempt -lt 3 ]]; then
                  echo "Retrying in 5 seconds..."
                  sleep 5
                fi
              fi
            done
            
            if [[ -n "$RELEASE_DATA" && "$RELEASE_DATA" != "{}" ]]; then
              # Validate release data before processing
              if validate_release_data "$RELEASE_DATA" "$TAG"; then
                DATE=$(echo "$RELEASE_DATA" | jq -r '.published_at')
                NAME=$(echo "$RELEASE_DATA" | jq -r '.name // .tag_name')
                BODY=$(echo "$RELEASE_DATA" | jq -r '.body // ""')
                
                if process_release "$REPO" "$TAG" "$URL" "$DATE" "$NAME" "$BODY"; then
                  PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
                fi
              else
                echo "‚ùå Release data validation failed for $TAG - skipping to prevent incomplete changelog"
              fi
            else
              echo "‚ùå Failed to fetch release details for $TAG after 3 attempts"
            fi
          else
            # Handle scheduled/manual runs - get recent releases (last 10 days)
            echo "Fetching recent releases from repositories..."
            
            # Calculate date threshold (10 days ago)
            CUTOFF_DATE=$(date -d '10 days ago' --iso-8601)
            echo "Looking for releases published after: $CUTOFF_DATE"
            
            # Process stable releases from ublue-os/bluefin
            echo ""
            echo "=== Processing stable releases from ublue-os/bluefin ==="
            STABLE_FILTER="[.[] | select(.tag_name | contains(\"stable\")) | select(.prerelease == false) | select(.published_at > \"$CUTOFF_DATE\")] | sort_by(.published_at) | reverse"
            STABLE_RELEASES=$(fetch_releases_with_retry "ublue-os/bluefin" "$STABLE_FILTER")
            
            if [[ "$STABLE_RELEASES" != "[]" && -n "$STABLE_RELEASES" ]]; then
              echo "Found $(echo "$STABLE_RELEASES" | jq length) stable release(s)"
              echo "$STABLE_RELEASES" | jq -c '.[]' | while read -r release; do
                TAG=$(echo "$release" | jq -r '.tag_name')
                URL=$(echo "$release" | jq -r '.html_url')
                DATE=$(echo "$release" | jq -r '.published_at')
                NAME=$(echo "$release" | jq -r '.name // .tag_name')
                BODY=$(echo "$release" | jq -r '.body // ""')
                
                # Validate release data before processing
                if validate_release_data "$release" "$TAG"; then
                  if process_release "ublue-os/bluefin" "$TAG" "$URL" "$DATE" "$NAME" "$BODY"; then
                    PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
                  fi
                else
                  echo "‚ùå Skipping $TAG due to validation failure"
                fi
              done
            else
              echo "No recent stable releases found"
            fi
            
            # Process GTS releases from ublue-os/bluefin
            echo ""
            echo "=== Processing GTS releases from ublue-os/bluefin ==="
            GTS_FILTER="[.[] | select(.tag_name | contains(\"gts\")) | select(.prerelease == false) | select(.published_at > \"$CUTOFF_DATE\")] | sort_by(.published_at) | reverse"
            GTS_RELEASES=$(fetch_releases_with_retry "ublue-os/bluefin" "$GTS_FILTER")
            
            if [[ "$GTS_RELEASES" != "[]" && -n "$GTS_RELEASES" ]]; then
              echo "Found $(echo "$GTS_RELEASES" | jq length) GTS release(s)"
              echo "$GTS_RELEASES" | jq -c '.[]' | while read -r release; do
                TAG=$(echo "$release" | jq -r '.tag_name')
                URL=$(echo "$release" | jq -r '.html_url')
                DATE=$(echo "$release" | jq -r '.published_at')
                NAME=$(echo "$release" | jq -r '.name // .tag_name')
                BODY=$(echo "$release" | jq -r '.body // ""')
                
                # Validate release data before processing
                if validate_release_data "$release" "$TAG"; then
                  if process_release "ublue-os/bluefin" "$TAG" "$URL" "$DATE" "$NAME" "$BODY"; then
                    PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
                  fi
                else
                  echo "‚ùå Skipping $TAG due to validation failure"
                fi
              done
            else
              echo "No recent GTS releases found"
            fi
            
            # Process LTS releases from ublue-os/bluefin-lts
            echo ""
            echo "=== Processing LTS releases from ublue-os/bluefin-lts ==="
            LTS_FILTER="[.[] | select(.published_at > \"$CUTOFF_DATE\")] | sort_by(.published_at) | reverse"
            LTS_RELEASES=$(fetch_releases_with_retry "ublue-os/bluefin-lts" "$LTS_FILTER")
            
            if [[ "$LTS_RELEASES" != "[]" && -n "$LTS_RELEASES" ]]; then
              echo "Found $(echo "$LTS_RELEASES" | jq length) LTS release(s)"
              echo "$LTS_RELEASES" | jq -c '.[]' | while read -r release; do
                TAG=$(echo "$release" | jq -r '.tag_name')
                URL=$(echo "$release" | jq -r '.html_url')
                DATE=$(echo "$release" | jq -r '.published_at')
                NAME=$(echo "$release" | jq -r '.name // .tag_name')
                BODY=$(echo "$release" | jq -r '.body // ""')
                
                # Validate release data before processing
                if validate_release_data "$release" "$TAG"; then
                  if process_release "ublue-os/bluefin-lts" "$TAG" "$URL" "$DATE" "$NAME" "$BODY"; then
                    PROCESSED_COUNT=$((PROCESSED_COUNT + 1))
                  fi
                else
                  echo "‚ùå Skipping $TAG due to validation failure"
                fi
              done
            else
              echo "No recent LTS releases found"
            fi
          fi

          echo "processed_count=$PROCESSED_COUNT" >> $GITHUB_OUTPUT
          
          echo ""
          echo "=== Release Sync Summary ==="
          echo "Trigger: ${{ github.event_name }}"
          echo "Cutoff date: ${CUTOFF_DATE:-N/A}"
          echo "Processed releases: $PROCESSED_COUNT"
          
          if [[ $PROCESSED_COUNT -gt 0 ]]; then
            echo "‚úÖ Successfully processed $PROCESSED_COUNT release(s)"
          else
            echo "‚ÑπÔ∏è No new releases found to process"
          fi

      - name: Create Pull Request
        if: steps.process.outputs.processed_count != '0'
        uses: peter-evans/create-pull-request@271a8d0340265f705b14b6d32b9829c1cb33d45e # v7
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          commit-message: "feat(changelogs): sync ${{ steps.process.outputs.processed_count }} Bluefin release(s)"
          title: "feat(changelogs): sync ${{ steps.process.outputs.processed_count }} Bluefin release(s)"
          body: |
            ## Bluefin Release Sync
            
            This PR automatically syncs ${{ steps.process.outputs.processed_count }} new Bluefin release changelog(s).
            
            **Trigger:** ${{ github.event_name }}
            **Processed:** ${{ steps.process.outputs.processed_count }} release(s)
            
            Generated by the automated release sync workflow.
          branch: changelogs/sync-bluefin-releases
          delete-branch: true
          draft: false

      - name: Enable auto-merge
        if: steps.process.outputs.processed_count != '0'
        run: |
          # Get the PR number from the previous step
          PR_NUMBER=$(gh pr list --head changelogs/sync-bluefin-releases --json number --jq '.[0].number')
          
          if [[ -n "$PR_NUMBER" && "$PR_NUMBER" != "null" ]]; then
            echo "Enabling auto-merge for PR #$PR_NUMBER"
            gh pr merge $PR_NUMBER --auto --merge
            echo "‚úÖ Auto-merge enabled for PR #$PR_NUMBER"
          else
            echo "‚ö†Ô∏è Could not find PR to enable auto-merge"
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
